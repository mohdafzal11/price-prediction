import { GetServerSideProps } from 'next';
import prisma from '../../../src/lib/prisma';

// This is a placeholder component that won't actually be rendered
const DynamicTokensSitemap = () => null;

// Function to escape XML special characters
const escapeXml = (unsafe: string) => {
  return unsafe.replace(/[<>&'"]/g, (c) => {
    switch (c) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
      case "'": return '&apos;';
      case '"': return '&quot;';
      default: return c;
    }
  });
};

// Constants
const TOKENS_PER_SITEMAP = 200;

export const getServerSideProps: GetServerSideProps = async ({ params, res }) => {
  try {
    // Set the content type to XML
    res.setHeader('Content-Type', 'application/xml');
    // res.setHeader('Cache-Control', 'public, s-maxage=86400, stale-while-revalidate=43200');
    res.setHeader('Cache-Control', 'public, s-maxage=86400, stale-while-revalidate=43200');


    // Parse the page number parameter
    const pageNumberStr = (params?.range as string).replace('.xml', '');
    
    // Convert page number to integer
    const pageNumber = parseInt(pageNumberStr, 10);
    
    if (isNaN(pageNumber) || pageNumber < 1) {
      throw new Error(`Invalid page number: ${pageNumberStr}`);
    }
    
    // Calculate start and end indices based on page number
    // Page 1 = indices 0-199, Page 2 = indices 200-399, etc.
    const start = (pageNumber - 1) * TOKENS_PER_SITEMAP;
    const end = start + TOKENS_PER_SITEMAP - 1;
    
    // console.log(`Calculated range for page ${pageNumber}: start=${start}, end=${end}`); // Debug logging

    // Calculate skip and take values for database query
    const skip = start;
    const take = TOKENS_PER_SITEMAP;

    // Fetch tokens that should be in sitemap (either in top 2000 or previously marked as inSitemap)
    const tokens = await prisma.token.findMany({
      where: {
        OR: [
          {
            rank: {
              not: null,
              lte: 2000
            }
          },
          { inSitemap: true }
        ]
      },
      select: {
        id: true,
        name: true,
        slug: true,
        ticker: true,
        updatedAt: true,
        rank: true,
      },
      orderBy: [
        // First order by rank (nulls last)
        {
          rank: 'asc',
        },
        // Then by name for consistent ordering of tokens without rank
        {
          name: 'asc',
        }
      ],
      skip,
      take
    });
    
    // console.log(`Generated sitemap for tokens ${start}-${end} with ${tokens.length} tokens`);

    // Get the base URL from environment or use a default
    let baseUrl = 'https://droomdroom.com';
    if (!baseUrl.includes('/price')) {
      let url = new URL(baseUrl);
      url.pathname = '/price';
      baseUrl = url.toString();
    }
    // Create XML sitemap
    const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    <!-- Generated by DroomDroom BaseURL: ${baseUrl}-->
      ${tokens.flatMap(token => {
        const baseTokenUrl = `${baseUrl}/${token.slug}`;
        const predictionUrl = `${baseUrl}/${token.slug}/prediction`;
        
        // Generate two entries per token - one for main page and one for prediction
        return [
          // Regular token page
          `<url>
            <loc>${escapeXml(baseTokenUrl)}</loc>
            <lastmod>${token.updatedAt.toISOString()}</lastmod>
            <changefreq>${token.rank && token.rank <= 100 ? 'hourly' : 
                       token.rank && token.rank <= 500 ? 'daily' : 
                       token.rank && token.rank <= 1000 ? 'daily' : 'weekly'}</changefreq>
            <priority>${token.rank && token.rank <= 100 ? '0.9' : 
                     token.rank && token.rank <= 500 ? '0.8' : 
                     token.rank && token.rank <= 1000 ? '0.7' : 
                     token.rank && token.rank <= 2000 ? '0.6' : '0.5'}</priority>
          </url>`,
          
          // Prediction page
          // `<url>
          //   <loc>${escapeXml(predictionUrl)}</loc>
          //   <lastmod>${token.updatedAt.toISOString()}</lastmod>
          //   <changefreq>${token.rank && token.rank <= 100 ? 'daily' : 'weekly'}</changefreq>
          //   <priority>${token.rank && token.rank <= 100 ? '0.8' : 
          //            token.rank && token.rank <= 500 ? '0.7' : 
          //            token.rank && token.rank <= 1000 ? '0.6' : 
          //            token.rank && token.rank <= 2000 ? '0.5' : '0.4'}</priority>
          // </url>`
        ];
      }).join('')}
    </urlset>`;

    // Send the XML response
    res.write(sitemap);
    res.end();

    // Return no props as we've already sent the response
    return {
      props: {},
    };
  } catch (error : any) {
    console.error('Error generating tokens sitemap:', error);
    res.statusCode = 500;
    res.write(`Error generating tokens sitemap: ${error.message}`);
    res.end();

    return {
      props: {},
    };
  }
};

export default DynamicTokensSitemap;
